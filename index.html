<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ©ãƒ–ãƒ©ã‚¤ãƒ–ï¼ã‚«ãƒ¼ãƒ‰ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #4A9FDB 0%, #7BC8E8 50%, #5DADE2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #2874A6;
            margin-bottom: 10px;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        h1 img {
            height: 80px;
            width: auto;
        }

        .subtitle {
            text-align: center;
            color: #5DADE2;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .stats {
            text-align: center;
            color: #666;
            font-size: 13px;
            margin-bottom: 20px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .stats strong {
            color: #2874A6;
            font-size: 16px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #2874A6;
            font-size: 18px;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2874A6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sync-status {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-size: 13px;
            display: none;
        }

        .sync-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .sync-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .sync-status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }

        .progress-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 30px;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: linear-gradient(90deg, #4A9FDB, #2874A6);
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            white-space: nowrap;
            position: relative;
        }

        .tab .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
            min-width: 18px;
            text-align: center;
        }

        .tab.active {
            background: linear-gradient(135deg, #4A9FDB, #2874A6);
            color: white;
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42, 116, 166, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls-admin {
            display: none;
            gap: 10px;
            flex-wrap: wrap;
        }

        .controls-admin.visible {
            display: flex;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #2874A6;
            color: white;
        }

        .btn-secondary {
            background: #E8F6FB;
            color: #2874A6;
        }

        .btn-warning {
            background: #5DADE2;
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .card-grid.edit-mode .card-item {
            cursor: default;
        }

        .card-item {
            position: relative;
            aspect-ratio: 2/3;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            background: #f0f0f0;
            border: 3px solid transparent;
        }

        .card-item:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .card-grid.edit-mode .card-item:hover {
            transform: scale(1.02);
        }

        .card-item.owned {
            border-color: #4CAF50;
        }

        .card-item.owned::after {
            content: 'âœ“';
            position: absolute;
            top: 5px;
            right: 5px;
            background: #4CAF50;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            z-index: 2;
        }

        .card-item.owned img {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .card-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.3s;
        }

        .card-number {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
        }

        .card-item-actions {
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            display: none;
            gap: 5px;
            z-index: 3;
        }

        .edit-mode .card-item-actions {
            display: flex;
        }

        .card-item-actions button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .card-item-actions button:hover {
            transform: scale(1.05);
        }

        .btn-edit-card {
            background: #2196F3;
            color: white;
        }

        .btn-delete-card {
            background: #f44336;
            color: white;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #2874A6;
        }

        .form-helper {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        .form-error {
            font-size: 12px;
            color: #e74c3c;
            margin-top: 5px;
            display: none;
        }

        .file-upload-area {
            border: 2px dashed #4A9FDB;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #F0F8FF;
        }

        .file-upload-area:hover {
            background: #E8F6FB;
            border-color: #2874A6;
        }

        .file-upload-area.has-image {
            border-style: solid;
            border-color: #4CAF50;
            padding: 10px;
        }

        .preview-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }

        .migration-notice {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .migration-notice strong {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
        }

        @media (max-width: 768px) {
            .card-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }

            h1 {
                font-size: 22px;
            }

            .tab {
                padding: 10px 16px;
                font-size: 14px;
            }

            .controls {
                justify-content: center;
            }

            .btn {
                font-size: 12px;
                padding: 8px 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%23FF69B4'/%3E%3Ctext x='50' y='65' text-anchor='middle' font-size='50' fill='white' font-family='Arial'%3Eâ™ª%3C/text%3E%3C/svg%3E" alt="ãƒ©ãƒ–ãƒ©ã‚¤ãƒ–ï¼ãƒ­ã‚´" id="logoImage">
            ã‚«ãƒ¼ãƒ‰ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
        </h1>
        <div class="subtitle">Card List - ã‚«ãƒ¼ãƒ‰ã‚’æ¢ã™ (GitHubè‡ªå‹•åŒæœŸç‰ˆ)</div>
        
        <div id="migrationNotice" class="migration-notice" style="display:none;">
            <strong>âš ï¸ ãƒ‡ãƒ¼ã‚¿ç§»è¡Œä¸­...</strong>
            <p>LocalStorageã‹ã‚‰IndexedDBã¸ãƒ‡ãƒ¼ã‚¿ã‚’ç§»è¡Œã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„...</p>
        </div>

        <div id="syncStatus" class="sync-status"></div>

        <div id="loadingScreen" class="loading">
            <div class="loading-spinner"></div>
            <div>ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        </div>

        <div id="mainContent" style="display:none;">
            <div class="stats" id="statsDisplay">å…¨ã‚·ãƒªãƒ¼ã‚º: <strong>0</strong>æšç™»éŒ² | æ‰€æœ‰: <strong>0</strong>æš (<strong>0</strong>%)</div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar">0 / 0 (0%)</div>
            </div>

            <div class="tabs" id="tabs"></div>

            <div class="controls">
                <button class="btn btn-warning" id="editModeBtn" onclick="toggleEditMode()">âœï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰</button>
            </div>

            <div class="controls-admin" id="controlsAdmin">
                <button class="btn btn-primary" onclick="openAddModal()">â• ã‚«ãƒ¼ãƒ‰è¿½åŠ </button>
                <button class="btn btn-secondary" onclick="exportData()">ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ä¿å­˜</button>
                <button class="btn btn-secondary" onclick="importData()">ğŸ“‚ ãƒ‡ãƒ¼ã‚¿èª­è¾¼</button>
                <button class="btn btn-secondary" onclick="clearAll()">ğŸ—‘ï¸ å…¨ã‚¯ãƒªã‚¢</button>
            </div>

            <div class="card-grid" id="cardGrid"></div>
        </div>
    </div>

    <!-- ã‚«ãƒ¼ãƒ‰è¿½åŠ /ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="modal" id="cardModal">
        <div class="modal-content">
            <h3 id="modalTitle">æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ </h3>
            <div class="form-group">
                <label>ã‚·ãƒªãƒ¼ã‚ºå</label>
                <input type="text" id="cardSeries" placeholder="ä¾‹: BP03">
                <div class="form-helper">åŠè§’è‹±æ•°å­—ã‚’æ¨å¥¨(è‡ªå‹•ã§æ­£è¦åŒ–ã•ã‚Œã¾ã™)</div>
            </div>
            <div class="form-group">
                <label>ã‚«ãƒ¼ãƒ‰ç•ªå·</label>
                <input type="text" id="cardNumber" placeholder="ä¾‹: BP03-001">
                <div class="form-helper">åŠè§’è‹±æ•°å­—ã‚’æ¨å¥¨(è‡ªå‹•ã§æ­£è¦åŒ–ã•ã‚Œã¾ã™)</div>
                <div class="form-error" id="cardNumberError"></div>
            </div>
            <div class="form-group">
                <label>ã‚«ãƒ¼ãƒ‰ç”»åƒ</label>
                <div class="file-upload-area" id="fileUploadArea" onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
                    <div id="uploadText">
                        <p>ğŸ“ ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç”»åƒã‚’é¸æŠ</p>
                        <p style="font-size: 12px; color: #999; margin-top: 5px;">å¯¾å¿œå½¢å¼: JPG, PNG, GIF</p>
                        <p style="font-size: 12px; color: #666; margin-top: 5px;">â€»è‡ªå‹•çš„ã«åœ§ç¸®ã•ã‚Œã¾ã™</p>
                    </div>
                    <img id="previewImage" class="preview-image" style="display:none;">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="saveCardBtn" onclick="saveCard()">ä¿å­˜</button>
                <button class="btn btn-secondary" onclick="closeModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <script>
        // IndexedDBè¨­å®š
        const DB_NAME = 'LoveliveCardDB';
        const DB_VERSION = 1;
        const CARD_STORE = 'cards';
        const OWNED_STORE = 'owned';
        
        // GitHubè¨­å®šï¼ˆconfig.jsonã‹ã‚‰èª­ã¿è¾¼ã‚€ï¼‰
        let GITHUB_CONFIG = null;
        
        let db = null;
        let currentSeries = null;
        let editMode = false;
        let editingCard = null;
        let currentImageData = null;

        // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) {
                    throw new Error('config.jsonã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                const config = await response.json();
                GITHUB_CONFIG = config.github;
                return config;
            } catch (error) {
                console.error('Config load error:', error);
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                GITHUB_CONFIG = {
                    username: 'extremeyj',
                    repo: 'lovelive_card_list',
                    branch: 'main',
                    dataPath: 'card_data/ver.1.3.json'
                };
                showSyncStatus('âš ï¸ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ä½¿ç”¨ã—ã¾ã™', 'error');
                return { github: GITHUB_CONFIG, app: { autoSync: true, syncOnStartup: true } };
            }
        }

        // IndexedDBã‚’åˆæœŸåŒ–
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // ã‚«ãƒ¼ãƒ‰ã‚¹ãƒˆã‚¢
                    if (!db.objectStoreNames.contains(CARD_STORE)) {
                        const cardStore = db.createObjectStore(CARD_STORE, { keyPath: 'id', autoIncrement: true });
                        cardStore.createIndex('series', 'series', { unique: false });
                        cardStore.createIndex('number', 'number', { unique: false });
                        cardStore.createIndex('seriesNumber', ['series', 'number'], { unique: true });
                    }
                    
                    // æ‰€æœ‰ã‚«ãƒ¼ãƒ‰ã‚¹ãƒˆã‚¢
                    if (!db.objectStoreNames.contains(OWNED_STORE)) {
                        db.createObjectStore(OWNED_STORE, { keyPath: 'cardNumber' });
                    }
                };
            });
        }

        // åŒæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¡¨ç¤º
        function showSyncStatus(message, type = 'loading') {
            const statusEl = document.getElementById('syncStatus');
            statusEl.textContent = message;
            statusEl.className = `sync-status ${type}`;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusEl.className = 'sync-status';
                }, 5000);
            }
        }

        // GitHubã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
        async function loadFromGitHub() {
            if (!GITHUB_CONFIG) {
                throw new Error('GitHubè¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
            }
            
            const url = `https://raw.githubusercontent.com/${GITHUB_CONFIG.username}/${GITHUB_CONFIG.repo}/${GITHUB_CONFIG.branch}/${GITHUB_CONFIG.dataPath}`;
            
            try {
                showSyncStatus('ğŸ”„ GitHubã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...', 'loading');
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('GitHub load error:', error);
                throw error;
            }
        }

        // èµ·å‹•æ™‚ã®è‡ªå‹•åŒæœŸ
        async function autoSyncOnStartup() {
            try {
                const data = await loadFromGitHub();
                
                if (!data.cards || !Array.isArray(data.cards)) {
                    throw new Error('ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™');
                }

                // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                const transaction = db.transaction([CARD_STORE, OWNED_STORE], 'readwrite');
                await transaction.objectStore(CARD_STORE).clear();
                await transaction.objectStore(OWNED_STORE).clear();
                
                // ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                for (const card of data.cards) {
                    await addCard(card.series, card.number, card.image);
                }
                
                // æ‰€æœ‰æƒ…å ±ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (data.owned && Array.isArray(data.owned)) {
                    for (const cardNumber of data.owned) {
                        await setOwnedCard(cardNumber, true);
                    }
                }
                
                showSyncStatus(`âœ… ${data.cards.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`, 'success');
            } catch (error) {
                console.error('Auto sync error:', error);
                showSyncStatus('âš ï¸ GitHubæ¥ç¶šå¤±æ•—: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™', 'error');
            }
        }

        // ç”»åƒã‚’åœ§ç¸®
        function compressImage(file, maxWidth = 800, maxHeight = 1200, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        
                        // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ãƒªã‚µã‚¤ã‚º
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width = width * ratio;
                            height = height * ratio;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // åœ§ç¸®ã—ã¦Base64ã«å¤‰æ›
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // å…¥åŠ›å€¤ã‚’æ­£è¦åŒ–
        function normalizeInput(str) {
            if (!str) return '';
            return str
                .trim()
                .replace(/[ï¼¡-ï¼ºï½-ï½šï¼-ï¼™]/g, function(s) {
                    return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
                })
                .replace(/[ï¼âˆ’â€]/g, '-')
                .replace(/[ï¼‹]/g, '+');
        }

        // ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
        function getAllCards() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CARD_STORE], 'readonly');
                const store = transaction.objectStore(CARD_STORE);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ã‚·ãƒªãƒ¼ã‚ºåˆ¥ã«ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
        function getCardsBySeries(series) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CARD_STORE], 'readonly');
                const store = transaction.objectStore(CARD_STORE);
                const index = store.index('series');
                const request = index.getAll(series);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
        function addCard(series, number, image) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CARD_STORE], 'readwrite');
                const store = transaction.objectStore(CARD_STORE);
                const card = { series, number, image };
                const request = store.add(card);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°
        function updateCard(id, series, number, image) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CARD_STORE], 'readwrite');
                const store = transaction.objectStore(CARD_STORE);
                const card = { id, series, number, image };
                const request = store.put(card);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
        function deleteCardFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CARD_STORE], 'readwrite');
                const store = transaction.objectStore(CARD_STORE);
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // æ‰€æœ‰ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
        function getOwnedCards() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([OWNED_STORE], 'readonly');
                const store = transaction.objectStore(OWNED_STORE);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const owned = request.result.map(item => item.cardNumber);
                    resolve(new Set(owned));
                };
                request.onerror = () => reject(request.error);
            });
        }

        // æ‰€æœ‰çŠ¶æ…‹ã‚’ä¿å­˜
        function setOwnedCard(cardNumber, owned) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([OWNED_STORE], 'readwrite');
                const store = transaction.objectStore(OWNED_STORE);
                
                if (owned) {
                    const request = store.put({ cardNumber });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                } else {
                    const request = store.delete(cardNumber);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                }
            });
        }

        // LocalStorageã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ç§»è¡Œ
        async function migrateFromLocalStorage() {
            const oldData = localStorage.getItem('loveliveCardData');
            const oldOwned = localStorage.getItem('loveliveOwnedCards');
            
            if (!oldData) return false;
            
            try {
                document.getElementById('migrationNotice').style.display = 'block';
                
                const cardData = JSON.parse(oldData);
                const ownedCards = oldOwned ? JSON.parse(oldOwned) : [];
                
                // ã‚«ãƒ¼ãƒ‰ã‚’ç§»è¡Œ
                for (const [series, cards] of Object.entries(cardData)) {
                    for (const card of cards) {
                        await addCard(series, card.number, card.image);
                    }
                }
                
                // æ‰€æœ‰æƒ…å ±ã‚’ç§»è¡Œ
                for (const cardNumber of ownedCards) {
                    await setOwnedCard(cardNumber, true);
                }
                
                // ç§»è¡Œå®Œäº†å¾Œã€LocalStorageã‚’ã‚¯ãƒªã‚¢
                localStorage.removeItem('loveliveCardData');
                localStorage.removeItem('loveliveOwnedCards');
                
                document.getElementById('migrationNotice').style.display = 'none';
                alert('LocalStorageã‹ã‚‰IndexedDBã¸ã®ãƒ‡ãƒ¼ã‚¿ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸï¼\nä»Šå¾Œã¯ã‚ˆã‚Šå¤§å®¹é‡ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã§ãã¾ã™ã€‚');
                
                return true;
            } catch (error) {
                console.error('Migration error:', error);
                document.getElementById('migrationNotice').style.display = 'none';
                alert('ãƒ‡ãƒ¼ã‚¿ç§»è¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
                return false;
            }
        }

        // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
        async function updateStats() {
            try {
                const allCards = await getAllCards();
                const ownedCards = await getOwnedCards();
                
                const totalCards = allCards.length;
                const totalOwned = allCards.filter(card => ownedCards.has(card.number)).length;
                const percentage = totalCards > 0 ? Math.round((totalOwned / totalCards) * 100) : 0;
                
                document.getElementById('statsDisplay').innerHTML = 
                    `å…¨ã‚·ãƒªãƒ¼ã‚º: <strong>${totalCards}</strong>æšç™»éŒ² | æ‰€æœ‰: <strong>${totalOwned}</strong>æš (<strong>${percentage}</strong>%)`;
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // ã‚¿ãƒ–ã‚’æç”»
        async function renderTabs() {
            try {
                const tabsContainer = document.getElementById('tabs');
                tabsContainer.innerHTML = '';
                
                const allCards = await getAllCards();
                const seriesMap = {};
                
                allCards.forEach(card => {
                    if (!seriesMap[card.series]) {
                        seriesMap[card.series] = 0;
                    }
                    seriesMap[card.series]++;
                });
                
                const seriesList = Object.keys(seriesMap).sort();
                
                if (seriesList.length === 0) {
                    currentSeries = null;
                    return;
                }
                
                if (!currentSeries || !seriesList.includes(currentSeries)) {
                    currentSeries = seriesList[0];
                }
                
                seriesList.forEach(series => {
                    const button = document.createElement('button');
                    button.className = 'tab' + (series === currentSeries ? ' active' : '');
                    
                    const badge = document.createElement('span');
                    badge.className = 'badge';
                    badge.textContent = seriesMap[series];
                    
                    button.textContent = series;
                    button.appendChild(badge);
                    
                    button.onclick = () => {
                        currentSeries = series;
                        render();
                    };
                    tabsContainer.appendChild(button);
                });
            } catch (error) {
                console.error('Error rendering tabs:', error);
            }
        }

        // ã‚«ãƒ¼ãƒ‰ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»
        async function renderCards() {
            try {
                const grid = document.getElementById('cardGrid');
                grid.innerHTML = '';
                grid.className = 'card-grid' + (editMode ? ' edit-mode' : '');
                
                if (!currentSeries) {
                    grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #999;">ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</div>';
                    return;
                }
                
                const cards = await getCardsBySeries(currentSeries);
                const ownedCards = await getOwnedCards();
                
                cards.forEach(card => {
                    try {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card-item' + (ownedCards.has(card.number) ? ' owned' : '');
                        
                        const img = document.createElement('img');
                        img.src = card.image || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22300%22%3E%3Crect fill=%22%23f0f0f0%22 width=%22200%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E';
                        img.alt = card.number;
                        
                        const cardNumberDiv = document.createElement('div');
                        cardNumberDiv.className = 'card-number';
                        cardNumberDiv.textContent = card.number;
                        
                        if (editMode) {
                            const actionsDiv = document.createElement('div');
                            actionsDiv.className = 'card-item-actions';
                            
                            const editBtn = document.createElement('button');
                            editBtn.className = 'btn-edit-card';
                            editBtn.textContent = 'ç·¨é›†';
                            editBtn.onclick = (e) => {
                                e.stopPropagation();
                                openEditModal(card);
                            };
                            
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'btn-delete-card';
                            deleteBtn.textContent = 'å‰Šé™¤';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                deleteCard(card);
                            };
                            
                            actionsDiv.appendChild(editBtn);
                            actionsDiv.appendChild(deleteBtn);
                            cardElement.appendChild(actionsDiv);
                        } else {
                            cardElement.onclick = () => toggleOwned(card.number);
                        }
                        
                        cardElement.appendChild(img);
                        cardElement.appendChild(cardNumberDiv);
                        grid.appendChild(cardElement);
                    } catch (error) {
                        console.error('Error rendering card:', card.number, error);
                    }
                });
            } catch (error) {
                console.error('Error rendering cards:', error);
            }
        }

        // é€²æ—ãƒãƒ¼ã‚’æ›´æ–°
        async function updateProgress() {
            try {
                if (!currentSeries) {
                    document.getElementById('progressBar').style.width = '0%';
                    document.getElementById('progressBar').textContent = '0 / 0 (0%)';
                    return;
                }
                
                const cards = await getCardsBySeries(currentSeries);
                const ownedCards = await getOwnedCards();
                
                const total = cards.length;
                const owned = cards.filter(card => ownedCards.has(card.number)).length;
                const percentage = total > 0 ? Math.round((owned / total) * 100) : 0;
                
                const progressBar = document.getElementById('progressBar');
                progressBar.style.width = percentage + '%';
                progressBar.textContent = `${owned} / ${total} (${percentage}%)`;
            } catch (error) {
                console.error('Error updating progress:', error);
            }
        }

        // ã‚«ãƒ¼ãƒ‰ã®æ‰€æœ‰çŠ¶æ…‹ã‚’ãƒˆã‚°ãƒ«
        async function toggleOwned(cardNumber) {
            if (editMode) return;
            
            try {
                const ownedCards = await getOwnedCards();
                const isOwned = ownedCards.has(cardNumber);
                await setOwnedCard(cardNumber, !isOwned);
                render();
            } catch (error) {
                console.error('Error toggling owned:', error);
                alert('æ‰€æœ‰çŠ¶æ…‹ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒˆã‚°ãƒ«
        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const adminControls = document.getElementById('controlsAdmin');
            
            if (editMode) {
                btn.textContent = 'âœ“ ç·¨é›†å®Œäº†';
                btn.className = 'btn btn-primary';
                adminControls.classList.add('visible');
            } else {
                btn.textContent = 'âœï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰';
                btn.className = 'btn btn-warning';
                adminControls.classList.remove('visible');
            }
            render();
        }

        // ã™ã¹ã¦ã‚’æç”»
        async function render() {
            await renderTabs();
            await renderCards();
            await updateProgress();
            await updateStats();
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã(æ–°è¦è¿½åŠ )
        function openAddModal() {
            editingCard = null;
            currentImageData = null;
            document.getElementById('modalTitle').textContent = 'æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ';
            document.getElementById('cardSeries').value = currentSeries || '';
            document.getElementById('cardNumber').value = '';
            document.getElementById('previewImage').style.display = 'none';
            document.getElementById('uploadText').style.display = 'block';
            document.getElementById('fileUploadArea').classList.remove('has-image');
            document.getElementById('cardNumberError').style.display = 'none';
            document.getElementById('cardModal').classList.add('show');
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã(ç·¨é›†)
        function openEditModal(card) {
            editingCard = card;
            currentImageData = card.image;
            
            document.getElementById('modalTitle').textContent = 'ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†';
            document.getElementById('cardSeries').value = card.series;
            document.getElementById('cardNumber').value = card.number;
            
            const previewImage = document.getElementById('previewImage');
            previewImage.src = card.image;
            previewImage.style.display = 'block';
            document.getElementById('uploadText').style.display = 'none';
            document.getElementById('fileUploadArea').classList.add('has-image');
            document.getElementById('cardNumberError').style.display = 'none';
            
            document.getElementById('cardModal').classList.add('show');
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeModal() {
            document.getElementById('cardModal').classList.remove('show');
            editingCard = null;
            currentImageData = null;
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå‡¦ç†
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                // ç”»åƒã‚’åœ§ç¸®
                const compressedImage = await compressImage(file);
                currentImageData = compressedImage;
                
                const previewImage = document.getElementById('previewImage');
                previewImage.src = compressedImage;
                previewImage.style.display = 'block';
                document.getElementById('uploadText').style.display = 'none';
                document.getElementById('fileUploadArea').classList.add('has-image');
                
                // åœ§ç¸®å¾Œã®ã‚µã‚¤ã‚ºã‚’è¡¨ç¤º(ãƒ‡ãƒãƒƒã‚°ç”¨)
                const sizeKB = Math.round(compressedImage.length * 0.75 / 1024);
                console.log(`ç”»åƒã‚’åœ§ç¸®ã—ã¾ã—ãŸ: ç´„${sizeKB}KB`);
            } catch (error) {
                console.error('Image compression error:', error);
                alert('ç”»åƒã®åœ§ç¸®ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜
        async function saveCard() {
            const seriesInput = document.getElementById('cardSeries').value;
            const cardNumberInput = document.getElementById('cardNumber').value;
            
            const series = normalizeInput(seriesInput);
            const cardNumber = normalizeInput(cardNumberInput);
            
            const errorElement = document.getElementById('cardNumberError');
            errorElement.style.display = 'none';
            
            if (!series || !cardNumber) {
                alert('ã‚·ãƒªãƒ¼ã‚ºåã¨ã‚«ãƒ¼ãƒ‰ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!currentImageData) {
                alert('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const saveBtn = document.getElementById('saveCardBtn');
                saveBtn.disabled = true;
                saveBtn.textContent = 'ä¿å­˜ä¸­...';
                
                if (editingCard) {
                    // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰
                    // é‡è¤‡ãƒã‚§ãƒƒã‚¯(è‡ªåˆ†è‡ªèº«ä»¥å¤–)
                    const allCards = await getAllCards();
                    const isDuplicate = allCards.some(c => 
                        c.series === series && 
                        c.number === cardNumber && 
                        c.id !== editingCard.id
                    );
                    
                    if (isDuplicate) {
                        errorElement.textContent = `ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¼ãƒ‰ç•ªå·ã€Œ${cardNumber}ã€ã¯æ—¢ã«ã‚·ãƒªãƒ¼ã‚ºã€Œ${series}ã€ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™`;
                        errorElement.style.display = 'block';
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'ä¿å­˜';
                        return;
                    }
                    
                    // æ‰€æœ‰çŠ¶æ…‹ã‚’å¼•ãç¶™ã
                    const ownedCards = await getOwnedCards();
                    if (ownedCards.has(editingCard.number) && editingCard.number !== cardNumber) {
                        await setOwnedCard(editingCard.number, false);
                        await setOwnedCard(cardNumber, true);
                    }
                    
                    await updateCard(editingCard.id, series, cardNumber, currentImageData);
                    currentSeries = series;
                } else {
                    // æ–°è¦è¿½åŠ ãƒ¢ãƒ¼ãƒ‰
                    const allCards = await getAllCards();
                    const existingCard = allCards.find(c => c.series === series && c.number === cardNumber);
                    
                    if (existingCard) {
                        const seriesCards = allCards.filter(c => c.series === series);
                        errorElement.textContent = `ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¼ãƒ‰ç•ªå·ã€Œ${cardNumber}ã€ã¯æ—¢ã«ã‚·ãƒªãƒ¼ã‚ºã€Œ${series}ã€ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™(${seriesCards.length}æšä¸­)`;
                        errorElement.style.display = 'block';
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'ä¿å­˜';
                        return;
                    }
                    
                    await addCard(series, cardNumber, currentImageData);
                    currentSeries = series;
                }
                
                await render();
                closeModal();
                
                const allCards = await getAllCards();
                const seriesCards = allCards.filter(c => c.series === series);
                alert(`ã‚«ãƒ¼ãƒ‰ã€Œ${cardNumber}ã€ã‚’${editingCard ? 'æ›´æ–°' : 'è¿½åŠ '}ã—ã¾ã—ãŸï¼\nã‚·ãƒªãƒ¼ã‚ºã€Œ${series}ã€ã®ç™»éŒ²æšæ•°: ${seriesCards.length}æš`);
                
                saveBtn.disabled = false;
                saveBtn.textContent = 'ä¿å­˜';
            } catch (error) {
                console.error('Error saving card:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                document.getElementById('saveCardBtn').disabled = false;
                document.getElementById('saveCardBtn').textContent = 'ä¿å­˜';
            }
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
        async function deleteCard(card) {
            if (!confirm(`${card.number} ã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
                return;
            }
            
            try {
                await deleteCardFromDB(card.id);
                await setOwnedCard(card.number, false);
                
                // ã‚·ãƒªãƒ¼ã‚ºãŒç©ºã«ãªã£ãŸã‹ç¢ºèª
                const remainingCards = await getCardsBySeries(card.series);
                if (remainingCards.length === 0) {
                    const allCards = await getAllCards();
                    const seriesMap = {};
                    allCards.forEach(c => {
                        if (!seriesMap[c.series]) seriesMap[c.series] = true;
                    });
                    const seriesList = Object.keys(seriesMap);
                    if (seriesList.length > 0) {
                        currentSeries = seriesList[0];
                    } else {
                        currentSeries = null;
                    }
                }
                
                await render();
            } catch (error) {
                console.error('Error deleting card:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportData() {
            try {
                const allCards = await getAllCards();
                const ownedCards = await getOwnedCards();
                
                const data = {
                    cards: allCards,
                    owned: [...ownedCards],
                    exportDate: new Date().toISOString()
                };
                
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lovelive_cards_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼');
            } catch (error) {
                console.error('Export error:', error);
                alert('ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (!data.cards || !Array.isArray(data.cards)) {
                            alert('ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™');
                            return;
                        }
                        
                        if (!confirm(`${data.cards.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹?`)) {
                            return;
                        }
                        
                        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                        const transaction = db.transaction([CARD_STORE, OWNED_STORE], 'readwrite');
                        await transaction.objectStore(CARD_STORE).clear();
                        await transaction.objectStore(OWNED_STORE).clear();
                        
                        // ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                        for (const card of data.cards) {
                            await addCard(card.series, card.number, card.image);
                        }
                        
                        // æ‰€æœ‰æƒ…å ±ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                        if (data.owned && Array.isArray(data.owned)) {
                            for (const cardNumber of data.owned) {
                                await setOwnedCard(cardNumber, true);
                            }
                        }
                        
                        await render();
                        alert('ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼');
                    } catch (err) {
                        console.error('Import error:', err);
                        alert('ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ã™ã¹ã¦ã‚¯ãƒªã‚¢
        async function clearAll() {
            if (confirm('æœ¬å½“ã«ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹?\n(ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆã¨æ‰€æœ‰æƒ…å ±ãŒã™ã¹ã¦å‰Šé™¤ã•ã‚Œã¾ã™)')) {
                if (confirm('ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚æœ¬å½“ã«ã‚ˆã‚ã—ã„ã§ã™ã‹?')) {
                    try {
                        const transaction = db.transaction([CARD_STORE, OWNED_STORE], 'readwrite');
                        await transaction.objectStore(CARD_STORE).clear();
                        await transaction.objectStore(OWNED_STORE).clear();
                        
                        currentSeries = null;
                        await render();
                        alert('ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
                    } catch (error) {
                        console.error('Clear error:', error);
                        alert('ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                }
            }
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        document.getElementById('cardModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // åˆæœŸåŒ–
        async function init() {
            try {
                // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
                const config = await loadConfig();
                
                await initDB();
                
                // LocalStorageã‹ã‚‰ã®ç§»è¡Œã‚’ãƒã‚§ãƒƒã‚¯
                await migrateFromLocalStorage();
                
                // è‡ªå‹•åŒæœŸã‚’å®Ÿè¡Œï¼ˆè¨­å®šã§æœ‰åŠ¹ãªå ´åˆï¼‰
                if (config.app.syncOnStartup) {
                    await autoSyncOnStartup();
                }
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤º
                await render();
                
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loadingScreen').innerHTML = 
                    '<div style="color: #e74c3c;">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message + '</div>';
            }
        }

        // ã‚¢ãƒ—ãƒªèµ·å‹•
        init();
    </script>
</body>
</html>
